# 이 문제는 무슨 소리인지 해석하는데 시간이 걸림...
# 직접 그려보고 해당하는 합을 구하는거라고 이해하면 편함
# 다만 문제가 하나하나 더하는건 코딩 효율이 너무 떨어짐. 경우의 수가 너무 많음
# 그래서 가장 편한 방법은 누적합을 사용하면 됨
# =============== 구간합 ================
# 구간합이란 배열에서 특정 구간에 속하는 값들의 합을 계산하는 방법
# =============== 누적합 ================
# 누적합이란 구간합을 더 빠르게 계산하기 위해 미리 배열의 누적된 합을 계산해두는 방법
# ex
# 이하 내용 설명을 위해 A[1]는 A의 1번째 항이자 최초의 항임을 의미하고, S[2]는 A의 1,2 번째 항들을 더한 값을 의미함
# A = [2, 3, 7, 5, 1]
# S[1] = A[1] = 2
# S[2] = A[1] + A[2] = 2 + 3 = 5
# S[3] = A[1] + A[2] + A[3] = 2 + 3 + 7 = 12
# S[4] = A[1] + A[2] + A[3] + A[4] = 2 + 3 + 7 + 5 = 17
# S[5] = A[1] + A[2] + A[3] + A[4] + A[5] = 2 + 3 + 7 + 5 + 1 = 18
# 그럼 여기서 A[2] 부터 A[4]의 값은 S[4] - S[1]이라 할 수 있음
# 같은 원리로 2차원 구간합은
# sum(i,j,x,y)=S[x][y]−S[i−1][y]−S[x][j−1]+S[i−1][j−1]

# 배열의 크기 N, M 입력받기
N, M = map(int, input().split())
# N x M 배열 입력받기
arr = [list(map(int, input().split())) for _ in range(N)]
# 누적합 배열 초기화 (N+1 x M+1 크기로 생성)
S = [[0] * (M + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(1, M + 1):
        S[i][j] = arr[i-1][j-1] + S[i-1][j] + S[i][j-1] - S[i-1][j-1]

# 합을 구할 부분의 개수 K 입력받기
K = int(input())
# 쿼리 입력 받기 // 쿼리 형태 (i,j,x,y)
arr2 = [list(map(int, input().split())) for _ in range(K)]

# 각 쿼리 처리
for elements in arr2:
    i, j, x, y = elements
    # 구간합 계산
    result = S[x][y] - S[i-1][y] - S[x][j-1] + S[i-1][j-1]

    # 결과 출력
    print(result)
